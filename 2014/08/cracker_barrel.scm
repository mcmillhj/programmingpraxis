;; list of all possible-moves
(define possible-moves 
  '((0 1 3) (0 2 5)
    (1 3 6) (1 4 8)
    (2 4 7) (2 5 9)
    (3 1 0) (3 4 5) (3 6 10) (3 7 12)
    (4 7 11) (4 8 13)
    (5 2 0) (5 4 3) (5 8 12) (5 9 14)
    (6 3 1) (6 7 8)
    (7 4 2) (7 8 9)
    (8 4 1) (8 7 6)
    (9 5 2) (9 8 7)
    (10 6 3) (10 11 12)
    (11 7 4) (11 12 13)
    (12 7 3) (12 8 5) (12 11 10) (12 13 14)
    (13 12 11) (13 8 4)
    (14 9 5) (14 13 12)))

;; we can see from above that many of these triplets share the same
;; middle digit, we can use these to reduce the size of our list of moves
;; (0 1 3)  <=> (3 1 0)
;; (0 2 5)  <=> (5 2 0)
;; (1 4 8)  <=> (8 4 1)
;; (2 4 7)  <=> (7 4 2)
;; (2 5 9)  <=> (9 5 2)
;; (3 4 5)  <=> (5 4 3)
;; (3 6 10) <=> (10 6 3)
;; (3 7 12) <=> (12 7 3)
;; we can now say that a triplet (a b c) represents both the moves
;; (a b c) AND (c b a)
;; this allows us to reduce our list of moves from 36 -> 18
(define compressed-possible-moves 
  '((0 1 3) (0 2 5)
    (1 3 6) (1 4 8)
    (2 4 7) (2 5 9)
    (3 4 5) (3 6 10) (3 7 12)
    (4 7 11) (4 8 13)
    (5 8 12) (5 9 14)
    (6 7 8)
    (7 8 9)
    (10 11 12)
    (11 12 13)
    (12 13 14)))

(define initial-board '((1 2 3 4 5 6 7 8 9 10 11 12 13 14)))
(define (identity x) x)
(define (mappend f . xss) (apply append (apply map f xss)))
(define (filter pred? xs)
  (let loop ((xs xs) (ys '()))
    (cond ((null? xs) (reverse ys))
          ((pred? (car xs))
            (loop (cdr xs) (cons (car xs) ys)))
          (else (loop (cdr xs) ys)))))
(define (remove x xs)
  (let loop ((xs xs) (zs '()))
    (cond ((null? xs) (reverse zs))
          ((equal? (car xs) x) (loop (cdr xs) zs))
          (else (loop (cdr xs) (cons (car xs) zs))))))
(define (insert x xs)
  (if (null? xs) (list x)
    (if (< x (car xs)) (cons x xs)
      (cons (car xs) (insert x (cdr xs))))))

(define (can-move? board move)
  (let ((from (car move))
        (over (cadr move))
        (to   (caddr move))
        (b    (car board)))
    (and (member from b)
         (member over b)
         (not (member to b)))))

(define (flip-move move)
  (list (caddr move) (cadr move) (car move)))

(define (make-move board move)
  (cons (insert (caddr move)
                (remove (car move)
                        (remove (cadr move) (car board))))
        (cons move (cdr board))))

(define (move board move)
  (letrec ((move2 (flip-move move))
           (canmove1 (can-move? board move))
           (canmove2 (can-move? board move2)))
    (cond ((and canmove1 canmove2)
           (cons (make-move board move) (make-move board move2)))
          (canmove1 (make-move board move))
          (canmove2 (make-move board move2))
          (else #f))))


(define (all-moves board)
  (filter identity 
          (map (lambda (m) (move board m)) compressed-possible-moves)))

(define (solve init)
  (let loop ((k 13)
             (boards (list init)))
    (if (= 0 k) boards
      (loop (- k 1) (mappend all-moves boards)))))

(let ((solutions (solve initial-board)))
  (display (length solutions)) (newline)
  (display (length (filter (lambda (x) (equal? (car x) '(0))) solutions))) (newline)
  (display (list-ref solutions 17493)) (newline))

